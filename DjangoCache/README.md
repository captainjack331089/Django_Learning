- 缓存
  - 存储中间数据的一种介质
  - 目的
    - 缓解服务器的读写压力
    - 提升服务器的响应速度
    - 提升用户体验
  - 原则
    - 较少的代码 
    - 对缓存后端封装一致性操作（有一点orm的感觉）
    - 可扩展性
      - 应该存在通用基类
  - Django中内置了缓存框架的实现
    - Django内置缓存实现
      - 基于数据库
        - 创建 缓存表
        - 配置 缓存信息
          - CACHES
          - 缓存实现
          - 指定缓存实现后端
          - 指定缓存位置
          - 默认缓存超时时间
          - 版本信息
          - key统一前缀
      - 基于文件系统
      - 基于内存
      - 基于Memercache
        - 内存级数据库
  - Django-redis-cache
    - 使用redis实现django-cache的扩展
    - 操作缓存的API没有发生任何变更 
    - 变更的就是连接缓存的配置
  - 缓存使用
    - 使用系统封装的
      - 装饰器封装在视图函数上
      - 模版也可以缓存
    - 使用 cache对象原生操作
      - set
      - add
      - remove
      - clear
      - setmany
      - getmany
      - delete
      - deletemany
    - 缓存操作的API和操作字典基本一致
    - 核心点就是key的一个选择
      - 视图函数
      - ip
      - 使用用户的唯一标识(session，cookie，etc)
    - 多缓存
      - 写多套配置 ，定义不同的名字
      - 存入缓存的时候，获取不同的缓存对象
      - cache['cache_name']
      - @cache_page(30,cache='cache_name')
- 中间件
  - django内置的一个底层插件
  - 从属于面向切面编程（AOP）
    - 在不修改源代码的情况下，动态去添加一下业务逻辑处理
    - 中间件的典型实现就是 装饰器
      - 中间件就是使用类装饰器实现的
    - 面向切面编程 
      - 切点
        - process_request
        - process_view
        - process_template_response
        - process_response
      - 切面
        - 切点处切开可以获得的数据
    - 实现，使用
      - process_request
        - 统计，打印
        - 优先级调度
          - 黑名单
          - 白名单
        - 反爬，频率控制
          - N时间段之内只能请求一次
          - 单位时间之内最多访问N次 
            - 需要记录每次请求的时间
            - 数据结构
              - key-value value  = []
            - 在判断单位时间请求次数的时候，判断的是列表长度
            - 在判断之前进行简单的数据清洗
      - process_view
        - CSRF（防跨站攻击）
          - 首先判断了两种豁免条件
          - 判断请求是否 安全
          - POST请求如何验证CSRF
            - 在request.POST.get(*csrftokenmiddleware\*)
            - 验证和请求对应的token是否正确
      - process-response
        - 跨域处理
          - ip和端口不一致，就属于跨域。
          - 跨域的行为校验是浏览器行为
          - 实现跨域
            - 服务器端添加属性，允许所有域名访问
            - 在客户端伪装
        - 对响应进行统一处理
  - 书写，自定义中间件
    - 创建目录
    - 创建python文件
    - 创建中间件子类
      - MiddlewareMixin
    - 实现对应的切点函数
    - 注册中间件
  - 中间件的执行顺序
    - 从上到下逐个执行
    - 当我们在切点出切开的时候，后续中间件不再执行
- 分页器
  - 分页是提升了用户体验，并且见效服务器的负担而开发的
  - 原生实现
    - 偏移+限制
    - offset limit
  - 封装实现
    - paginator
      - 需要使用数据源和每一页的数据量来进行构建
      - 可以获取某一页
      - 可以获取所有页码
      - 可以获取有多少数据，多少页
    - page
      - 具体一页的一个载体
      - 可以获取当前第几页
      - 可以获取对象列表
      - 也可以获取兄弟信息
        - 是否有上一页
        - 是否有下一页
        - 上一页页码
        - 下一页页码
        - 是否有其他页
- 验证码
  - 防止恶意用户
  - 原生绘制
    - pillow
      - image： 画布
        - 尺寸
        - 颜色
        - 模式
          - RGB
      - imagedraw： 画笔
        - 属于哪一个画布
        - 画完的东西在哪
        - 封装绘制的API
          - 文字
          - 点
          - 线
          - 弧
      - imagefont：字体
        - 画笔的辅助工具
        - 字体设置绘制样式
  - 需要将画布转换成二进制流，并且添加格式限定
  - 内存流
    - BytesIO
    - 将图片存到内存流中
    - 从流中获取到数据值
  - 通过HTTPResponse返回图片内容
    - content_type
    - MIME
      - 标识打开我们数据的一个应用程序
      - image/png
  - 验证码的验证
    - 客户端验证
    - 服务器端验证
      - 在验证码生成的时候存储验证码
      - 在提交的时候验证验证码的有效性
  - 验证码的刷新策略
    - 浏览器的缓存策略
      - 是以url为标识
    - 解决方案
      - 每次给不同的地址
        - 对地质进行一个参数拼接，每次传递不同的参数









### PROJECT

- 创建一个新闻主页（3秒缓存）

- 搭建缓存redis

- 创建中间件的包

  - 用来获取ip
  - 指定指定用户做一些事情（比如抢票，抢票作弊）
  - 创建ip黑名单，限制访问流量，屏蔽用户
  - 如果遇到错误页面redirect跳转

- 分页器中的csrf开关

  - 创建一个主页并POST，利用中间件的csrf装饰器开关csrf验证

    

- 创建一个分页页面，并有页码，页码亮示，跳转，等bootstrap，js支持
- 创建一个 验证码 